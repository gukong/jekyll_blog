---
layout: post
title: "工厂方法模式"
date: 2016-04-05 21:46:13 +0800
comments: true
categories: 架构
excerpt: 工程方法模式，总的来说，[生成器]封装[物件]的生成过程，通过继承的方式最大程度的让[生成器]、[物件]、[使用者]、[其他外部力量]解耦。

---

#说一说工程方法模式

###定义：
	定义创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到其子类。
	
###解析：
	按照书上给的列子，怎么都不觉得他应该叫【工厂方法模式】，叫【生成器模式】更贴切。
	
###可以先看一看类图
![image](http://7xtaiq.com1.z0.glb.clouddn.com/image/factory_method_pattern_big.png)
图1


###简化到关键部分是这样的
![image](http://7xtaiq.com1.z0.glb.clouddn.com/image/factory_method_pattern_sm.png)
图2

注意：`α射线聚能器`的实质就是`α远程聚能弹生成器`

###最最关键的部分是
![image](http://7xtaiq.com1.z0.glb.clouddn.com/image/factory_method_pattern_min.png)
图3

----

说穿了，这个模式根本就是在封装一个对象的初始化工作，所以我说应该叫【生成器模式】嘛。

抽丝剥茧看到了本质，再把拨开的皮一层一层复原。


一. `α射线聚能器`和`β射线聚能器`继承自`普通光线聚能器`

	为什么要继承自【普通光线聚能器】呢？
	因为【普通光线聚能器】可以提供统一的【给我生成一个聚能弹】的接口
	这样【聚能枪】只提供一个【普通光线聚能器】的插口就够了，而不需要为每一种聚能器提供不同的插口，图1 中的【第三方人物】可以向【聚能枪】的同一个插口插入不同的聚能弹生成器。

二. `α远程聚能弹`和`β爆破聚能弹`继承自`聚能弹`

	为什么要继承自【聚能弹】呢？
	为了使【聚能枪】只提供一个接口成为可能！
	【聚能弹】定义了炮弹的使用方法，继承自【聚能弹】的其他炮弹都该这么用。所以【聚能枪】可以使用不同聚能器生成的不同聚能弹。

总的来说，`生成器`封装`物件`的生成过程，通过继承的方式最大程度的让`生成器`、`物件`、`使用者`、`其他外部力量`解耦。

1. `使用者`只知道一个父类`生成器`和一个父类`物件`

2. 特定的`生成器`只关心特定的一种`物件`

3. `物件`只知道自己是怎么回事

4. `其他外部力量`知道每一种`生成器`，是他把特定的`生成器`传递给了`使用者`，传递何种`生成器`取决于他想看到何种由`使用者`使用`物件`后所表现的效果。因为`生成器`的存在，`其他外部里面`不需要知道`物件`的生成细节。

[源代码可以在这里下载](https://github.com/gukong/OCPattern.git)
